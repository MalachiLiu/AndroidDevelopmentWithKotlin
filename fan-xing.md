---
description: >-
  泛型是一种编程风格，指的是类，函数，数据结构或算法可以以某种方式编写，从而以后我们可以指定确切的类型。
  通常泛型提供类型安全性以及针对各种数据重用特定代码结构的能力。在本章，我们将了解泛型为什么会存在及如何定义泛型类、接口及函数。讨论如何在运行时处理泛型，以及泛型的继承关系，还有如何处理泛型的可空性。Kotlin中的泛型和Java很类似，不过Kotlin有一些新的改进，让我们开始吧～
---

# 泛型

## 为什么需要泛型？

我们在开发时经常会定义某一种特定数据类型（比如`Int`、`String`、`User`等）的集合，如果没有泛型，那么我们将不得不将每一种数据类型的集合类分开定义，比如`IntList`、`StringList`、`UserList`等等。我们可以想到，除了存储的数据类型以外，这些类将会有几乎一致的代码，这意味着我们要编写大量的重复代码，即使我们使用了继承来消除重复代码，仍然需要对每个类进行分别维护，这无疑是一个非常大的工作量。

在没有泛型的时候，我们可能会使用可以存储所有类型的通用集合（Java中的`Object`、Kotlin中的`Any?`），在取出数据的时候再进行数据类型的转换，这是一种解决方案，但是增加了冗余代码。

而泛型的出现将使这些问题迎刃而解，泛型在定义时可以用一个占位符代替实际类型，这个占位符叫做**类型参数**（type parameter）。下面是一个简单的泛型类定义：

```kotlin
class List<T> // T 是类型参数
```

类型参数的含义是我们定义的类会使用一种特定的类型，但该类型会延后在创建时指定，这样一个`List`类可以初始化为多种数据类型：

```kotlin
var intLsit : List<Int>
var stringLsit : List<String>
var userLsit : List<User>
```

`List`类使用类型参数进行初始化，来指定`List`中可以存储哪种数据类型。

## 类型形参和类型实参

在函数基础那一章我们提到过函数的参数有形参（函数声明时定义的变量）和实参（函数调用时传入的变量值）之分。类似地，在泛型中也有类型形参（泛型定义时的类型参数）和类型实参（泛型初始化时指定的实际类型）之分。

我们可以把类型形参用在方法中，以确保传入我们希望的数据类型或返回一个我们期望的类型：

```kotlin
class List<T> {
    fun add(item:T) { 
        // code
    }
    fun get(intex: Int): T { 
        // code
    }
}
```

而传入的数据类型以及返回的数据类型取决于我们使用这些方法时的类型实参：

```kotlin
class User(val name: String)

val userList = List<User>()
userList.add(User("Mamun"))
println(userList.getItemAt(0).name) 
```

当我们使用类型实参指定好数据类型后，编译器会为我们进行类型检查，以确保所有的对象都是我们指定的数据类型，因此，当我们尝试传入其它数据类型时，编译器会报错：

```kotlin
val userList = List<User>()
userList.add(User("Mamun"))
userList.add(true) // 错误，已经指定为User类型后，不能接收Boolean类型参数
```

## 泛型约束

默认情况下，我们可以使用任何类型作为类型参数，同时我们也可以限定我们使用参数类型的范围，要做到这一点，需要定义**参数类型边界**（type parameter bound），最常见的**泛型约束**（generic constraints）是**上界**（upper bound），`Any?`是所有的类型参数的隐式上界，这就是为什么下面两种声明是等价的：

```kotlin
class List<T>
class List<T: Any?>
```

